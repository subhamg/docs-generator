<!-- Generated by ai-agent on 2025-08-27 16:37:21Z. Source: https://github.com/subhamg/sprint-sync -->

# SprintSync Documentation

SprintSync is a full-stack monorepo designed for task management. It features a robust NestJS API with JWT authentication, PostgreSQL via TypeORM, and an innovative AI-powered daily plan suggestion service. The frontend is built with Next.js, leveraging Mantine UI, Redux Toolkit for global state, and TanStack Query for efficient data fetching.

## Tech Stack and System Diagram

The project is structured as a monorepo, orchestrating multiple applications and packages.

**Core Technologies:**

*   **Monorepo Management:** pnpm Workspaces, Turborepo
*   **Backend (API):**
    *   **Framework:** NestJS
    *   **ORM:** TypeORM
    *   **Database:** PostgreSQL (using `pg` driver)
    *   **Authentication:** JWT (Passport-JWT, bcrypt) with HTTP-only cookies
    *   **AI Integration:** OpenAI API (with a deterministic fallback stub)
    *   **Rate Limiting:** `@nestjs/throttler`
    *   **API Documentation:** Swagger (`@nestjs/swagger`)
*   **Frontend (Web):**
    *   **Framework:** Next.js (App Router)
    *   **UI Library:** Mantine
    *   **State Management:** Redux Toolkit
    *   **Data Fetching:** TanStack React Query
    *   **HTTP Client:** Axios
*   **Shared:**
    *   **Schema Validation:** Zod
    *   **Language:** TypeScript
    *   **Linting:** ESLint, Prettier

**System Architecture Diagram:**

```
+----------------+          +-------------------+          +-------------+
|    Web Client  |          |   API (NestJS)    |          | PostgreSQL  |
|    (Next.js)   |          |                   |          |             |
| - Mantine UI   |          | - JWT Auth        |          | - Users     |
| - Redux Toolkit| <------->| - TypeORM         |<-------->| - Tasks     |
| - React Query  |          | - Rate Limiting   |          |             |
| - Axios        |          |                   |          |             |
+----------------+          +---------^---------+          +-------------+
                                      |
                                      | Shared Schemas & Types
                                      | (@sprintsync/shared)
                                      |
                                      V
                              +----------------+
                              |   AI Service   |
                              |   (OpenAI)     |
                              | (Daily Plan    |
                              |   Suggestion)  |
                              +----------------+
```

## Getting Started

Follow these steps to set up and run the SprintSync project locally.

### Prerequisites

*   Node.js (LTS recommended)
*   pnpm (package manager)
*   PostgreSQL database instance (or Docker with `docker-compose` for local setup - not explicitly provided in this repo, but common for such stacks).

### Installation

1.  **Clone the repository:**
    ```bash
    git clone https://github.com/subhamg/sprint-sync.git
    cd sprint-sync
    ```
2.  **Install pnpm dependencies:**
    ```bash
    pnpm install
    ```

### Environment Variables

Create `.env` files in `apps/api` and `apps/web` based on the examples below.

**`apps/api/.env`:**

```env
# Database Configuration
DATABASE_URL="postgresql://user:pass@host:port/dbname" # Example: postgresql://admin:password@localhost:5432/sprintsync
DB_HOST=localhost
DB_PORT=5432
DB_USER=admin
DB_PASSWORD=password
DB_NAME=sprintsync

# JWT Secret for Authentication
JWT_SECRET=your_jwt_secret_key_here # Use a strong, random string in production

# Frontend CORS Origin
WEB_ORIGIN=http://localhost:3000

# OpenAI API (Optional: remove key to use deterministic stub)
OPENAI_API_KEY=your_openai_api_key_here
OPENAI_MODEL=gpt-4o-mini # e.g., gpt-3.5-turbo, gpt-4o-mini

# API Server Port
PORT=4000
```

**`apps/web/.env`:**

```env
# Public API URL for the Next.js app
NEXT_PUBLIC_API_URL=http://localhost:4000
```

### Running the Application

To start both the API and web applications:

```bash
pnpm dev
```

*   The API server will run on `http://localhost:4000` (or your configured `PORT`).
*   The web application will run on `http://localhost:3000`.

### Database Setup

The API is configured with `synchronize: true` in development (`apps/api/src/app.module.ts`). This automatically creates the database schema on application startup. Ensure your PostgreSQL instance is running and accessible with the credentials provided in `apps/api/.env`.

**Important:** `synchronize: true` is for development convenience only and should **not** be used in production. For production, TypeORM migrations should be generated and run explicitly.

### Running Tests

To execute tests for all workspaces:

```bash
pnpm test
```

*   API tests (Jest)
*   Web tests (Vitest)

## Project Structure Walkthrough

The project is organized as a Turborepo monorepo:

```
subhamg-sprint-sync/
├── apps/
│   ├── api/             # NestJS backend application
│   │   ├── src/
│   │   │   ├── app.module.ts
│   │   │   ├── main.ts
│   │   │   ├── entities/      # TypeORM entity definitions
│   │   │   │   ├── task.entity.ts
│   │   │   │   └── user.entity.ts
│   │   │   └── modules/       # Feature modules
│   │   │       ├── ai/
│   │   │       ├── auth/
│   │   │       ├── tasks/
│   │   │       └── users/
│   │   └── package.json
│   │   └── tsconfig.json
│   └── web/             # Next.js frontend application
│       ├── app/         # Next.js App Router pages
│       │   ├── (auth)/login/
│       │   ├── tasks/
│       │   ├── layout.tsx
│       │   └── providers.tsx
│       ├── components/    # Reusable UI components
│       ├── lib/           # Utility functions (HTTP client, Redux store)
│       ├── services/      # API client services
│       ├── package.json
│       └── tsconfig.json
├── packages/
│   └── shared/          # Shared types and schemas
│       ├── src/
│       │   ├── schemas.ts   # Zod validation schemas
│       │   └── types.ts     # Shared TypeScript interfaces/enums
│       └── package.json
│       └── tsconfig.json
├── package.json         # Root pnpm/Turborepo configuration
├── pnpm-lock.yaml
├── pnpm-workspace.yaml
├── turbo.json           # Turborepo task configuration
├── .editorconfig
├── .eslintrc.json
└── README.md
```

### Key Directories:

*   **`apps/api/`**: The NestJS application.
    *   `src/main.ts`: Entry point, sets up global pipes, CORS, and Swagger.
    *   `src/app.module.ts`: Root module, imports all feature modules and configures TypeORM.
    *   `src/entities/`: Defines `Task` and `User` TypeORM entities.
    *   `src/modules/`: Contains business logic organized by feature:
        *   `ai/`: Handles OpenAI integration for daily plan suggestions.
        *   `auth/`: Manages user authentication (login, logout, JWT strategy, guards).
        *   `tasks/`: Provides CRUD operations, status transitions, and time logging for tasks.
        *   `users/`: Basic user lookup services.
*   **`apps/web/`**: The Next.js frontend application.
    *   `app/`: Utilizes Next.js App Router for routing and page components. Includes login (`(auth)/login/page.tsx`) and tasks list (`tasks/page.tsx`).
    *   `components/`: Reusable UI elements built with Mantine.
    *   `lib/`: Contains `http.ts` for Axios configuration and `store.ts` for Redux Toolkit setup.
    *   `services/`: Frontend clients for interacting with the backend API (`AuthService`, `TasksService`).
*   **`packages/shared/`**: A shared library for common code.
    *   `src/types.ts`: Defines shared TypeScript interfaces and enums used across both frontend and backend.
    *   `src/schemas.ts`: Contains Zod schemas for input validation, ensuring consistency.

## Core Modules and Data Flow

### 1. Authentication Flow

1.  **Login:**
    *   Frontend sends `POST /auth/login` with `email` and `password`.
    *   `AuthController` calls `AuthService.validateUser`.
    *   `AuthService` uses `UsersService.findByEmail` and `bcrypt.compare` to verify credentials.
    *   If successful, `AuthService.issueJwtCookie` generates a JWT token including `userId` and `isAdmin`, then sets it as an `ss_access` HTTP-only cookie on the response.
    *   Frontend (in `AuthService.login`) handles the successful login, then immediately calls `GET /auth/me` to retrieve the current user's details.
    *   The user's `userId` and `isAdmin` status are then dispatched to the Redux store (`setAuth`).
2.  **Protected Routes:**
    *   For any protected API route, `JwtAuthGuard` intercepts the request.
    *   `JwtStrategy` extracts the `ss_access` cookie, verifies the JWT signature using `JWT_SECRET`, and attaches the decoded payload (`sub` as `userId`, `isAdmin`) to `req.user`.
    *   `AdminGuard` (used for `DELETE /tasks/:id`) further checks `req.user.isAdmin` for administrative privileges.
3.  **Logout:**
    *   Frontend sends `POST /auth/logout`.
    *   `AuthController` clears the `ss_access` cookie.
    *   Frontend dispatches `clearAuth` to reset the Redux state and redirects to `/login`.

### 2. Task Management Flow

1.  **List Tasks:**
    *   Frontend `TasksPage` uses `useQuery` (TanStack Query) with `tasksService.list` to fetch tasks.
    *   `TasksService` makes a `GET /tasks` request to the API.
    *   `TasksController.list` retrieves tasks via `TasksService.listForUser`, filtering by `userId` (or all tasks if the user is an admin and `all` query param is `true`).
    *   Results are ordered by `createdAt` descending.
2.  **Create Task:**
    *   (Frontend UI for this is not yet implemented, but the API endpoint exists).
    *   Frontend would send `POST /tasks` with `CreateTaskDto`.
    *   `TasksController.create` uses `TasksService.create` to create a new task, associating it with the authenticated user's `ownerId` (or a specified `dto.ownerId` if the user is an admin).
3.  **Update Task Status:**
    *   Frontend `TaskRow` component calls `onStatusChange` which triggers `statusMutation`.
    *   `statusMutation` calls `tasksService.updateStatus` which sends a `PATCH /tasks/:id/status` request with `nextStatus`.
    *   `TasksService.updateStatus` on the backend first verifies the user's access to the task via `getById`.
    *   It then checks `canTransition` logic (e.g., `TODO -> IN_PROGRESS`, `IN_PROGRESS -> DONE`). Illegal transitions throw `ForbiddenException`.
    *   If valid, the task's status is updated.
4.  **Log Time:**
    *   Frontend `TaskRow` component calls `onLogTime` which triggers `logTimeMutation`.
    *   `logTimeMutation` calls `tasksService.logTime` which sends a `POST /tasks/:id/log-time` request with `minutes`.
    *   `TasksService.logTime` on the backend verifies user access via `getById` and then increments the `totalMinutes` for the task.
5.  **Delete Task:**
    *   (Frontend UI is not implemented; currently only accessible via API directly).
    *   `DELETE /tasks/:id` is protected by `AdminGuard`, ensuring only administrators can delete tasks.

### 3. AI Daily Plan Suggestion Flow

1.  **Request Suggestion:**
    *   (Frontend UI for this is mentioned in `estimates.csv` but not implemented in the provided code).
    *   When implemented, frontend would make a `POST /ai/suggest` request.
    *   `AiController.suggest` (which is rate-limited by `@nestjs/throttler`) calls `AiService.suggestDailyPlan`.
2.  **Generate Plan:**
    *   `AiService.suggestDailyPlan` fetches all tasks for the authenticated user.
    *   If `OPENAI_API_KEY` is set in the environment, `callOpenAi` is invoked:
        *   It constructs a prompt based on the user's tasks.
        *   Calls the OpenAI chat completion API.
        *   Parses the JSON response into an `AiPlanResponse`.
        *   Includes a `try-catch` block to handle potential parsing errors and falls back to the deterministic stub.
    *   If `OPENAI_API_KEY` is not set, `buildDeterministicStub` is called:
        *   It generates a static plan based on the task statuses (e.g., prioritizing `IN_PROGRESS` then `TODO` tasks).

## API Reference (Summarized)

The NestJS API provides a comprehensive set of endpoints for task management and AI suggestions. Full interactive documentation is available via Swagger.

**Base URL:** `http://localhost:4000` (or as configured by `PORT` env variable)
**Swagger UI:** `http://localhost:4000/docs`

### Authentication Endpoints (`/auth`)

*   **`POST /auth/login`**
    *   **Description:** Authenticates a user with email and password. On success, sets an `ss_access` HTTP-only JWT cookie.
    *   **Request Body:** `{ email: string, password: string }`
    *   **Response:** `{ ok: boolean }`
*   **`POST /auth/logout`**
    *   **Description:** Clears the `ss_access` authentication cookie.
    *   **Response:** `{ ok: boolean }`
*   **`GET /auth/me`**
    *   **Description:** Returns the authenticated user's ID and admin status. Requires `ss_access` cookie.
    *   **Response:** `{ userId: string, isAdmin: boolean }`

### Tasks Endpoints (`/tasks`) - All require authentication

*   **`GET /tasks`**
    *   **Description:** Lists tasks. For regular users, lists their own tasks. For admin users, `?all=true` can be used to list all tasks in the system.
    *   **Query Params:** `all?: boolean`
    *   **Response:** `TaskDto[]`
*   **`POST /tasks`**
    *   **Description:** Creates a new task. Admin users can specify `ownerId`.
    *   **Request Body:** `CreateTaskDto` (`{ title: string, description?: string | null, ownerId?: string }`)
    *   **Response:** `TaskDto` (the newly created task)
*   **`GET /tasks/:id`**
    *   **Description:** Retrieves a specific task by ID. Requires ownership or admin privileges.
    *   **Response:** `TaskDto`
*   **`PUT /tasks/:id`**
    *   **Description:** Updates a task by ID. Requires ownership or admin privileges. Admin users can update `ownerId`.
    *   **Request Body:** `UpdateTaskDto` (`{ title?: string, description?: string | null, ownerId?: string }`)
    *   **Response:** `TaskDto` (the updated task)
*   **`PATCH /tasks/:id/status`**
    *   **Description:** Updates the status of a task. Only allows valid status transitions (e.g., TODO to IN_PROGRESS). Requires ownership or admin privileges.
    *   **Request Body:** `UpdateStatusDto` (`{ nextStatus: TaskStatus }`)
    *   **Response:** `TaskDto` (the task with updated status)
*   **`POST /tasks/:id/log-time`**
    *   **Description:** Logs time spent on a task, incrementing `totalMinutes`. Requires ownership or admin privileges.
    *   **Request Body:** `LogTimeDto` (`{ minutes: number }`)
    *   **Response:** `TaskDto` (the task with updated `totalMinutes`)
*   **`DELETE /tasks/:id`**
    *   **Description:** Deletes a task by ID. **Requires admin privileges (`AdminGuard`).**
    *   **Response:** `{ ok: boolean }`

### AI Endpoints (`/ai`) - All require authentication, rate-limited (5 requests/min)

*   **`POST /ai/suggest`**
    *   **Description:** Provides a daily plan suggestion based on the user's current tasks. Integrates with OpenAI if configured, otherwise provides a deterministic stub.
    *   **Response:** `AiPlanResponse` (`{ summary: string, priorities: { taskId: string, title: string, reason: string }[], blocks: { label: string, focus: string }[] }`)

## Configuration and Environment Variables

Configuration is primarily handled through environment variables, with Turborepo managing shared scripts and build outputs.

**Root `package.json` and `turbo.json`:**

*   **`pnpm-workspace.yaml`**: Defines the monorepo structure, including `apps/*`, `packages/*`, and `infra/*` (though `infra` is currently empty).
*   **`turbo.json`**: Configures Turborepo tasks for `build`, `dev`, `lint`, and `test`, including dependencies between tasks and output caching.

**Environment Variables:**

As detailed in the [Environment Setup](#environment-variables) section, specific `.env` files are used for each application:

*   **`apps/api/.env`**:
    *   `DATABASE_URL` (or `DB_HOST`, `DB_PORT`, `DB_USER`, `DB_PASSWORD`, `DB_NAME`): PostgreSQL connection details.
    *   `JWT_SECRET`: Secret key for JWT signing.
    *   `WEB_ORIGIN`: CORS origin for the frontend (important for cookie-based authentication).
    *   `OPENAI_API_KEY`: Required for OpenAI AI suggestions.
    *   `OPENAI_MODEL`: Specifies the OpenAI model to use.
    *   `PORT`: Port for the API server.
*   **`apps/web/.env`**:
    *   `NEXT_PUBLIC_API_URL`: The public-facing URL of the backend API, used by the Next.js frontend.

## Limitations and Next Steps

### Current Limitations

*   **Database Management:** The development setup uses `synchronize: true` for TypeORM, which is convenient but unsafe for production. There are no explicit migration scripts provided.
*   **User Management:** The API lacks a user registration endpoint, assuming users are pre-provisioned or created manually.
*   **AI Context:** The AI suggestion is basic, primarily based on task titles and statuses. It does not integrate with broader user context or historical data for more personalized recommendations.
*   **Frontend Features:** The web application is currently limited to listing tasks, updating their status, and logging time. Features like task creation, editing, AI suggestion display, and a detailed task view are not yet implemented.
*   **Robustness:** Limited global error handling, structured logging, and request ID tracking are noted as future work in `estimates.csv`.

### Next Steps (Based on `estimates.csv` and current state)

1.  **Database Migrations:** Implement TypeORM migrations for robust database schema evolution, replacing `synchronize: true` for production.
2.  **User Registration:** Add an API endpoint and corresponding frontend UI for user signup.
3.  **Enhanced AI:** Integrate more user context, preferences, and potentially historical task data into the AI suggestion service for richer, more accurate daily plans. Implement the frontend UI to display AI suggestions.
4.  **Full Task Management UI:** Develop comprehensive frontend components for creating, editing, and deleting tasks, as well as a detailed view for individual tasks.
5.  **Observability:** Implement structured logging, request ID tracking, and global exception filters in the API for better monitoring and debugging.
6.  **Dockerization:** Create `docker-compose` configurations for easy local deployment of the API, web, and database services.
7.  **CI/CD:** Set up GitHub Actions for continuous integration and deployment, including automated testing and linting.
8.  **Testing:** Expand unit and e2e tests for both API and web applications.

## License and Attribution

This project is open-source, attributed to **subhamg**. No specific license file was detected in the repository.
