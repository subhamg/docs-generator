import os
import sys
import argparse
from datetime import datetime
from typing import Tuple

try:
    # gitingest 0.3.x exposes ingest and ingest_async
    from gitingest import ingest
except Exception as e:
    ingest = None


def get_repo_context(source: str) -> Tuple[str, str, str]:
    """Return (summary, tree, content) from gitingest for a path or URL.

    The function prefers the GITHUB_TOKEN env var if present.
    """
    if ingest is None:
        raise RuntimeError("gitingest is not installed or failed to import")

    token = os.environ.get("GITHUB_TOKEN")
    # gitingest.ingest returns (summary, tree, content)
    if token:
        summary, tree, content = ingest(source, token=token)
    else:
        summary, tree, content = ingest(source)
    return summary, tree, content


def build_prompt(summary: str, tree: str, content: str, style: str) -> str:
    """Construct a prompt for Gemini given the gitingest outputs."""
    header = (
        "You are a senior software engineer. Generate concise, developer-grade documentation "
        "in Markdown for the following repository. Focus on architecture, setup, key flows, "
        "and extension points. Prefer readable headings, code blocks, and bullet lists."
    )
    if style:
        header += f"\nPreferred tone/style: {style}\n"

    # Keep prompt deterministic and structured for LLMs
    prompt = (
        f"{header}\n\n"
        "Output sections (use only if content exists):\n"
        "- Title and one-paragraph overview\n"
        "- Tech stack and system diagram (ASCII if helpful)\n"
        "- Getting started (install, env, run, tests)\n"
        "- Project structure walkthrough\n"
        "- Core modules and data flow\n"
        "- API or CLI reference (summarized)\n"
        "- Configuration and environment variables\n"
        "- Limitations and next steps\n"
        "- License and attribution (if detected)\n\n"
        "=== REPO SUMMARY ===\n" + summary + "\n\n"
        "=== REPO TREE ===\n" + tree + "\n\n"
        "=== REPO CONTENT DIGEST ===\n" + content + "\n"
    )
    return prompt


def generate_markdown_with_gemini(prompt: str, model_name: str) -> str:
    """Call Gemini to produce Markdown from the prompt."""
    import google.generativeai as genai

    api_key = os.environ.get("GEMINI_API_KEY") or os.environ.get("GOOGLE_API_KEY")
    if not api_key:
        raise RuntimeError("Set GEMINI_API_KEY or GOOGLE_API_KEY environment variable")

    genai.configure(api_key=api_key)

    # Reasonable default model for text generation
    model = genai.GenerativeModel(model_name or "gemini-2.5-flash")
    response = model.generate_content(prompt)
    if hasattr(response, "text") and response.text:
        return response.text
    # Fallback in case of structured responses
    if hasattr(response, "candidates") and response.candidates:
        parts = []
        for cand in response.candidates:
            for part in getattr(cand, "content", {}).get("parts", []):
                text = getattr(part, "text", None)
                if text:
                    parts.append(text)
        if parts:
            return "\n\n".join(parts)
    raise RuntimeError("Gemini returned an empty response")


def main(argv: list[str]) -> int:
    parser = argparse.ArgumentParser(
        description="Generate Markdown documentation for a GitHub repository using gitingest + Gemini."
    )
    parser.add_argument("source", help="GitHub URL or local path to repository")
    parser.add_argument(
        "-o", "--output", default="docs.md", help="Output Markdown file path (default: docs.md)"
    )
    parser.add_argument(
        "-m", "--model", default="gemini-2.5-flash", help="Gemini model name (default: gemini-2.5-flash)"
    )
    parser.add_argument(
        "--style", default="", help="Optional tone/style guidance for the documentation"
    )
    parser.add_argument(
        "--print", dest="to_stdout", action="store_true", help="Print generated Markdown to STDOUT"
    )

    args = parser.parse_args(argv)

    try:
        summary, tree, content = get_repo_context(args.source)
    except Exception as e:
        print(f"[error] Failed to ingest repository: {e}", file=sys.stderr)
        return 1

    prompt = build_prompt(summary, tree, content, args.style)

    try:
        markdown = generate_markdown_with_gemini(prompt, args.model)
    except Exception as e:
        print(f"[error] Gemini generation failed: {e}", file=sys.stderr)
        return 1

    timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%SZ")
    banner = f"<!-- Generated by ai-agent on {timestamp}. Source: {args.source} -->\n\n"
    output_md = banner + markdown.strip() + "\n"

    try:
        with open(args.output, "w", encoding="utf-8") as f:
            f.write(output_md)
    except Exception as e:
        print(f"[error] Failed to write output file {args.output}: {e}", file=sys.stderr)
        return 1

    if args.to_stdout:
        print(output_md)
    else:
        print(f"Wrote documentation to {args.output}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))


